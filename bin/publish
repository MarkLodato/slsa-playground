#!/usr/bin/env python3
"""SLSA Playground mock publication

This module simulates the *server-side* publication. Pretend that the CLI is
actually an RPC interface.
"""

import argparse
import base64
import hashlib
import json
import pathlib
import re
import types

from typing import Optional


def main():
    parser = argparse.ArgumentParser(
        description=__doc__.partition("\n\n")[2],
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "artifact",
        help="Path to artifact to publish; must be named *.tar.gz",
        type=pathlib.Path,
    )
    parser.add_argument(
        "attestation_bundle",
        help="Path to attestation bundle; must be named *.intoto.jsonl",
        type=pathlib.Path,
        nargs="?",
    )
    parser.add_argument(
        "--policy_dir",
        help="Directory from which to load policies (default: ./policy)",
        type=pathlib.Path,
        default="./policy",
    )
    args = parser.parse_args()

    package_name = package_name_from_filename(args.artifact.name)
    sha256_digest = hashlib.sha256(args.artifact.read_bytes()).digest()
    provenance = read_provenance(args.attestation_bundle, sha256_digest)
    verify_policy(package_name, provenance, args.policy_dir)
    publish(args.artifact)

    # TODO validate that the filename matches PKG-INFO


def package_name_from_filename(filename: str) -> str:
    """Extracts the package name portion of a canonical sdist filename.

    >>> package_name_from_filename("foo-bar-1.0.tar.gz")
    'foo-bar'
    """
    FILENAME_RE = re.compile(r"""^(?P<name>.+)-(?P<version>[^-]+)\.tar\.gz$""")
    m = FILENAME_RE.match(filename)
    if not m:
        raise Exception(f"{filename} does not match pattern '*-*.tar.gz'")
    return m.group("name")


def read_provenance(
    path: Optional[pathlib.Path], sha256_digest: bytes
) -> Optional[dict]:
    """Returns the provenance predicate at `path`, or None if `path` is None.

    Raises an exception if the provenance fails verification or if it does not
    contain `sha256_digest`.
    """
    # NOTE: In real code we might want to skip over unrecognized or irrelevant
    # provenance rather than raising an exception. But for the demo, it is more
    # illustrative to error out.
    PAYLOAD_TYPE = "application/vnd.in-toto+json"
    STATEMENT_TYPE = "https://in-toto.io/Statement/v1"
    PREDICATE_TYPE = "https://slsa.dev/provenance/v1"
    if not path:
        return None
    envelope = json.loads(path.read_text())
    check_eq(envelope["payloadType"], PAYLOAD_TYPE, "invalid payloadType")
    payload = base64.b64decode(envelope["payload"])
    # WARNING: this is a dummy signature that is not at all secure!
    # Also we should accept any signatures
    check_eq(len(envelope["signatures"]), 1, "unsupported number of signatures")
    keyid = envelope["signatures"][0]["keyid"]
    sig = envelope["signatures"][0]["sig"]
    if not raw_verify(payload, envelope["payloadType"], base64.b64decode(sig), keyid):
        raise Exception("invalid signature")
    statement = json.loads(payload.decode("utf-8"))
    check_eq(statement["_type"], STATEMENT_TYPE, "invalid _type")
    check_eq(statement["predicateType"], PREDICATE_TYPE, "invalid predicateType")
    if not any(
        bytes.fromhex(s["digest"]["sha256"]) == sha256_digest
        for s in statement["subject"]
    ):
        raise Exception(f"no subject found with digest.sha256 '{sha256_digest.hex()}'")
    predicate = statement["predicate"]
    # Fake:
    check_eq(
        predicate["runDetails"]["builder"]["id"],
        "https://example.com/" + keyid,
        "builder.id does not match signer",
    )
    return predicate


def raw_verify(payload: bytes, payloadType: str, signature: bytes, keyid: str) -> bool:
    """Returns true if `signature` is a signature over `message` by `keyid`.

    WARNING: This is not in any way secure!
    """
    hasher = hashlib.sha256()
    hasher.update(b"Fake signature\n")
    hasher.update(keyid.encode("utf-8"))
    hasher.update(b"\n")
    hasher.update(PAE(payloadType, payload))
    # print('got:     ', hasher.hexdigest())
    # print('expected:', signature.hex())
    return signature == hasher.digest()


def PAE(payloadType: str, payload: bytes) -> bytes:
    return b"DSSEv1 %d %b %d %b" % (
        len(payloadType),
        payloadType.encode("utf-8"),
        len(payload),
        payload,
    )


def verify_policy(
    package_name: str, provenance: dict, policy_dir: pathlib.Path
) -> None:
    """Raises exception if `provenance` doesn't match policy for `package_name`."""
    policy_path = policy_dir / (package_name + ".policy.json")
    if not policy_path.exists():
        # No policy = default allow
        return
    policy = json.loads(policy_path.read_text())
    check_eq(
        provenance["runDetails"]["builder"]["id"],
        policy["allow"]["builder"],
        "not built from the expected builder",
    )
    check_eq(
        provenance["buildDefinition"]["buildType"],
        "https://example.com/PythonBuild",
        "unrecognized buildType",
    )
    check_eq(
        provenance["buildDefinition"]["externalParameters"]["repository"],
        policy["allow"]["sourceRepo"],
        "not built from the expected source repository",
    )


def publish(artifact_path: pathlib.Path) -> None:
    """Publishes `artifact_path`, which is assumed to have a correct basename."""
    # TODO
    pass


def check_eq(actual, expected, error: str):
    if actual != expected:
        raise Exception(f"{error}: expected {expected!r}, got {actual!r}")


def check_in(actual, expected, error: str):
    if actual not in expected:
        raise Exception(f"{error}: expected one of {expected!r}, got {actual!r}")


if __name__ == "__main__":
    main()
